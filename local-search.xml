<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>原码、反码、补码、移码快速转换</title>
    <link href="/2024/09/17/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E7%A7%BB%E7%A0%81%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/09/17/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E7%A7%BB%E7%A0%81%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>由符号和数值一起编码表示的二进制数称为<strong>机器数</strong>或<strong>机器码</strong>。以下是一些常见的机器码及其用途：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240917201322168.png" alt="image-20240917201322168"></p><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p><strong>小数点的位置是固定的，约定小数点在某一个位置上</strong>，机器在处理定点数时，并不存储它的小数点；</p><p>定点数常只会用定点数表示<strong>纯小数</strong>或<strong>整数</strong>，当表示纯小数时，小数点约定在<strong>符号位</strong>和数值部分之间，表示整数时，则在数值部分的后面：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/fixedpoint.png" alt="定点数"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>前面定点数由于本身性质的限制，难以处理复杂的<strong>非纯小数</strong>和整数，此时就需要浮点数来处理了，浮点数也就是我们平时编程语言中用到的<code>float</code>和<code>double</code>。</p><p>所谓浮点，与定点相对，就是小数点是浮动的，不固定的，它的形式有点像我们熟悉的科学计数法，譬如<code>12.34</code>这个数，可以写成下面几种形式：<br>$$<br>12.34 &#x3D; 1.234\times10^1 &#x3D; 0.1234\times10^2 &#x3D; 1234\times10^{-2}<br>$$<br>后面这三种形式都能表示<code>12.34</code>这个数字，尽管它们的小数点位置各不相同，但因为后面乘了不同的<code>10</code>的幂次方，因此最终结果一致。</p><p>浮点数的标准形式如下，其中，<code>M</code>为尾数，<code>B</code>为基数，<code>E</code>为阶码：<br>$$<br>N &#x3D; M \times B^E<br>$$<br>上面 <code>12.34</code> 的例子是我们熟悉的十进制，轮到二进制时，上面式子中的基数 <code>B</code> 则会变成 <code>2</code> ：<br>$$<br>101.11 &#x3D; 10.111\times2^1 &#x3D; 1.0111\times2^2 &#x3D; 10111\times2^{-2} &#x3D; 0.10111\times2^3 &#x3D; 0.010111\times2^4<br>$$<br>（未完待续~）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flow-based Generative Model 笔记</title>
    <link href="/2024/09/16/Flow-based-Generative-Model-%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/09/16/Flow-based-Generative-Model-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>视频链接：<a href="https://www.youtube.com/watch?v=uXY18nzdSsM">https://www.youtube.com/watch?v=uXY18nzdSsM</a></p><h2 id="什么是Generator"><a href="#什么是Generator" class="headerlink" title="什么是Generator"></a>什么是Generator</h2><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916135738795.png" alt="image-20240916135738795"></p><p>$G$是一个network，经过这个 $G$ 可以将一般的分布（正态分布）转化成新的分布 $p_G$ 。尝试使用这种分布去拟合目标数据 $p_{data}$ 的分布，以此来生成类似的数据。</p><p>具体来说，可以将目标数据看成从其中采样出的m个data（下图中的$x_1, x_2, \cdots, x_m$），$G$ 的优化方向是使输入的数据 $z$ 经过变换后生成的数据 $x^i$ 和训练数据分布最接近，即最大化生成器 $G$ 在数据集 ${x^1, x^2, \cdots, x^m}$ 上的 <strong>对数似然函数</strong> $logP_G(x^i)$。<br>$$<br>G^{*}&#x3D;arg\max_{G}\sum_{i&#x3D;1}^{m}logP_{G}\big(x^{i}\big)\quad{x^{1},x^{2},…,x^{m}\big}\text{from}P_{data}(x)\tag{1}<br>$$</p><h2 id="前置数学知识"><a href="#前置数学知识" class="headerlink" title="前置数学知识"></a>前置数学知识</h2><h3 id="雅可比矩阵（Jacobian）"><a href="#雅可比矩阵（Jacobian）" class="headerlink" title="雅可比矩阵（Jacobian）"></a>雅可比矩阵（Jacobian）</h3><p>设有一个二维向量$z &#x3D; \begin{bmatrix}z_1\z_2\end{bmatrix}$，给定变换$f$，$x&#x3D;f(z)&#x3D;\begin{bmatrix}z_1 + z_2\2z_2\end{bmatrix}，$那么变换$f$的雅可比矩阵$J_f$为：<br>$$<br>J_f&#x3D;\begin{bmatrix}\frac{\partial x_1}{\partial z_1}&amp;\frac{\partial x_1}{\partial z_2}\\frac{\partial x_2}{\partial z_1}&amp;\frac{\partial x_2}{\partial z_2}\end{bmatrix}&#x3D;\begin{bmatrix}1&amp;1\2&amp;0\end{bmatrix}\tag{2}<br>$$<br>即分别计算变换前后对应的值 $x_i, z_i$ 的偏导数。其中，雅可比矩阵的<strong>每一列对应一个输入 $x$</strong> ，<strong>每一行对应一个输出 $z$</strong> ，计算偏导数使用的 $x, y$ 对应的下标，即为其在雅可比矩阵中的位置。</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916144126744.png" alt="image-20240916144126744"></p><h3 id="行列式（Determinant）"><a href="#行列式（Determinant）" class="headerlink" title="行列式（Determinant）"></a>行列式（Determinant）</h3><p>主要会用到<strong>行列式的几何意义</strong>：</p><p>n阶行列式是由n个n维向量组成，其结果为n维平行多面体的体积。</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916145838830.png" alt="image-20240916145838830"></p><h3 id="变量替换定理（Change-of-Variable-Theorem）"><a href="#变量替换定理（Change-of-Variable-Theorem）" class="headerlink" title="变量替换定理（Change of Variable Theorem）"></a>变量替换定理（Change of Variable Theorem）</h3><p>已知变换前的分布$\pi(z)$和变换后的分布$p(x)$，要得到变换前后的$\pi(z’), p(x’)$之间的关系：</p><p>现在假设从$z’$移动很小一段$\Delta z$，可以将这段区间内的分布看作均匀分布，则这段区间的积分是$\pi(z’) \Delta z$；同理，这段区间的值经过变换后得到$p(x)$分布上对应的区间积分为$p(x’) \Delta x$。根据上面的信息可以得到$\pi(z’), p(x’)$之间的关系:<br>$$<br>p(x^{\prime})\Delta x&#x3D;\pi(z^{\prime})\Delta z\p(x^{\prime})&#x3D;\pi(z^{\prime})\frac{\Delta z}{\Delta x}\p(x^{\prime})&#x3D;\pi(z^{\prime})\biggl|\frac{dz}{dx}\biggr|\tag{3}<br>$$<br><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916154119841.png" alt="image-20240916154119841"></p><p>拓展到二维，如下图，图中$\Delta x_{ij}$表示$\Delta z_i$改变时$\Delta x_j$的改变量，变换前的矩形部分的积分为$\pi(z’) \Delta z_1 \Delta z_2$，变换后的平行四边形部分的积分为$p(x’)S &#x3D; p(x’)\left|det\begin{bmatrix}\Delta x_{11}&amp;&amp;\Delta x_{21}\\Delta x_{12}&amp;&amp;\Delta x_{22}\end{bmatrix}\right|$，此处用到了上面<strong>行列式的几何意义</strong>：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916161742890.png" alt="image-20240916161742890"></p><p>然后再将得到的式子进行整理：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916162644712.png" alt="image-20240916162644712"></p><p>最终得到上图黄色框的式子，可见将$\pi(z’)$与$p(x’)$之间的差别转换成了$|det(J_{f^{-1}})|$</p><h2 id="Flow-based-Model"><a href="#Flow-based-Model" class="headerlink" title="Flow-based Model"></a>Flow-based Model</h2><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916163604373.png" alt="image-20240916163604373"></p><p>由上面前置知识的推导可得：<br>$$<br>p_{G}(x^{i})&#x3D;\pi(z^{i})|det(J_{G^{-1}})|\z^{i}&#x3D;G^{-1}(x^{i})\tag{4}<br>$$<br>再回到优化Generator上面，式(1)中目标函数$G^*$中的最大对数似然$logP_G(x^i)$可以展开为：<br>$$<br>logp_{G}\big(x^{i}\big)&#x3D;log\pi\left(G^{-1}\big(x^{i}\big)\right)+log|det(J_{G^{-1}})|\tag{5}<br>$$<br>然而要计算上面式子还需解决以下两个难点：</p><ul><li>能够简便计算出$det(J_G)$：难点在于高维的行列式计算复杂且耗时</li><li>$G$是可逆变换，且能够容易地得到$G^{-1}$的表达式</li></ul><p>同时还需要明确的是，与GAN的输入维度远小于输出维度不同，Flow-based Model要求变换前后的$x,z$维度相同</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>上面种种限制了单个G网络的复杂度，因此Flow-based Model的网络一般都是由多个G相连呈流式（flow）结构，这也是它名字的来源：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916170333266.png" alt="image-20240916165326940"></p><p>但在训练时我们通常是将所有的G看作一个整体进行训练</p><p>从式(5)中可以看出，训练时需要优化的部分就只有$G^{-1}$，训练完成后的$G^{-1}$再取逆变换即可得到用于图像生成的$G$</p><h3 id="Coupling-Layer"><a href="#Coupling-Layer" class="headerlink" title="Coupling Layer"></a>Coupling Layer</h3><p>前面提到，选取的G有讲究：首先它要方便去计算Jacobian矩阵，然后它还需要是可逆的，Coupling Layer就是满足这样条件的Generator。它的结构就如下所示：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916180511810.png" alt="image-20240916180511810"></p><p>首先将输入分为两个部分：</p><ul><li><p>前半部分$z_1$到$z_d$直接copy作为右边的前半部分$x_1$到$x_d$可。同时前半部分会经过一个F函数和一个H函数分别得到$\beta$序列和$\gamma$序列</p></li><li><p>后半部分$z_{d+1}$到$z_D$分别与前半部分得到的$\beta$序列进行点积，$\gamma$序列点加，后作为右边的后半部分。</p></li></ul><p>下面来看这个变换是如何应对上面提到的两个问题的：</p><ol><li><p>如何计算Coupling Layer的Jacobian</p><p>可以用下面的一张图来说明：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916183351697.png" alt="image-20240916183351697"></p><p>其中，左上子矩阵为<strong>单位矩阵</strong>，右上子矩阵为<strong>零矩阵</strong>，左下部分的矩阵虽然不知道，但根据分块计算行列式的方法，由于右上子矩阵为零矩阵，左下的子矩阵不会影响行列式最终的值，所以don’t care。</p><p>可以发现， Jacobian 矩阵的行列式<strong>最终的值只与右下子矩阵有关</strong>。右下角的 Jacobian矩阵 经过计算之后可以发现是一个<strong>对角矩阵</strong>，行列式的值由对角线元素的乘积决定，那么这个矩阵的Jacobian的计算公式为：<br>$$<br>\text{det} (J_G) &#x3D; \frac{\partial x_{d+1}}{\partial z_{d+1}} \frac{\partial x_{d+2}}{\partial z_{d+2}} \cdots \frac{\partial x_D}{\partial z_D}<br>$$</p></li><li><p>为什么变换 $G$ 是可逆的</p><p>首先，前半部分的$z_1$到$z_d$可以通过结果中的$x_1$到$x_d$直接得到，然后根据得到的$z_1$到$z_d$，再次进行F和H变换，最后将结果中的$x_{d+1}$到$x_D$先减去H变换的结果，再除以F变换的结果，即可得到后半部分的$z_{d+1}$到$z_D$</p></li></ol><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>把 Coupling Layer 叠加起来就可以获得一个完整的Generator：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916191153599.png" alt="image-20240916191153599"></p><p>如果像上图这样直接叠加的话，那么上半部分是一直不变的，相当于没有被优化到。这时就需要在叠加的时候使用一些手段。</p><p>比如在叠加的时候，将相邻的Coupling Layer反向叠加起来：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916191239846.png" alt="image-20240916191239846"></p><p>此外还有基于棋盘和基于通道的分离方法，分别在不同维度上进行分离：</p><p><img src="https://fufu-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20240916191851858.png" alt="image-20240916191851858"></p><p>以上即为Flow-based Generative Model的基本思想~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>视频异常检测-ep1</title>
    <link href="/2024/08/11/%E8%A7%86%E9%A2%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B-ep1/"/>
    <url>/2024/08/11/%E8%A7%86%E9%A2%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B-ep1/</url>
    
    <content type="html"><![CDATA[<h2 id="主要面临的挑战"><a href="#主要面临的挑战" class="headerlink" title="主要面临的挑战"></a>主要面临的挑战</h2><ol><li>异常事件定义的模糊性。正常样本与异常样本之间没有明确的划分边界。</li><li>异常事件定义的场景依赖性。同一事件在不同的场景下具有不同的异常属性。</li><li>异常事件的稀少性、多样性、不可穷举性。</li><li>训练样本中包含噪声，给样本信息带来干扰。</li><li>由于数据的隐私性，目前可用的公开数据集较少。异常样本的稀少性、不可穷举性限制了有监督算法在该领域的应用</li></ol><h2 id="视频异常分类"><a href="#视频异常分类" class="headerlink" title="视频异常分类"></a>视频异常分类</h2><p>根据一些公开的视频数据集和对监控视频的特点分析，可以把视频异常分成5种类型:</p><h3 id="外观异常"><a href="#外观异常" class="headerlink" title="外观异常"></a>外观异常</h3><p>这些异常可以被认为是场景中不寻常的物体出现。例如人行道上的骑自行车者，或马路上的纸箱。检测这些异常只需要检查<strong>1帧视频的局部区域</strong>。</p><h3 id="短期运动异常"><a href="#短期运动异常" class="headerlink" title="短期运动异常"></a>短期运动异常</h3><p>这些异常可以被认为是场景中不寻常的物体运动。例如一个人在图书馆跑步，或在军事基地附近闲逛。检测这些异常通常只需要<strong>在短时间内检查视频的局部区域</strong>。</p><p>外观异常和短期运动异常可以进一步称为局部异常，因为它们具有额外的属性。</p><h3 id="长期轨迹异常"><a href="#长期轨迹异常" class="headerlink" title="长期轨迹异常"></a>长期轨迹异常</h3><p>这些异常可以被认为是场景中不寻常的物体轨迹。例如在人行道上拐来拐去的人，或在车流中不断加塞的汽车。检测轨迹异常需要检查<strong>较长时间的视频片段</strong>。</p><h3 id="群体异常"><a href="#群体异常" class="headerlink" title="群体异常"></a>群体异常</h3><p>群体异常可以被认为是场景中不寻常的物体<strong>相互作用</strong>。比如一群人突然向四周跑动。检测群体异常需要分析视频中<strong>2个或多个区域之间的关系</strong>。</p><h3 id="时间异常"><a href="#时间异常" class="headerlink" title="时间异常"></a>时间异常</h3><p>这种异常与所有其他类型的异常是正交的。使这些活动异常的是它们发生的时间。这些异常在本质上与前面讨论的位置相关异常非常相似，只是<strong>相关的上下文是时间而不是空间</strong>。举个例子，人们在黎明时分进入游乐场。通常，检测这些异常只需要在一天的<strong>不同时间使用不同的正常状态模型</strong>。</p><p>事实上，在我们所描述的用于检测视频异常的公开数据集中，主要只有<strong>外观异常和短期运动异常</strong>。</p><p>不同类型的反常现象<strong>并不相互排斥</strong>。实际上，很难找到上面列出的某些类型的示例。对于异常人们通常认为是一个二分类场景，但实际上视频中的异常是有连续性的，它要维持一定的时间。当2个活动相似时，找到与我们的直觉概念相对应的特征是创建较好的视频异常检测算法的关键。</p><h2 id="检测算法分类"><a href="#检测算法分类" class="headerlink" title="检测算法分类"></a>检测算法分类</h2><h3 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h3><p>基于距离的方法是使用训练数据来<strong>构建一个正常模型</strong>，并从这个模型中<strong>测量偏差</strong>来确定异常的分数。通常，这些模型本身非常简单，但是巧妙地表示会带来良好的性能。以距离为基础的方法可以被视为概率和基于重建的方法的一种更一般的形式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本学习</title>
    <link href="/2024/08/08/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/08/08/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><ol><li><p>创建sh文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> hello_world.sh<br></code></pre></td></tr></table></figure></li><li><p>指定使用的解释器</p><p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br></code></pre></td></tr></table></figure></li><li><p>输出Hello World!</p><p>输出语法与php一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Hello World!&quot;<br></code></pre></td></tr></table></figure></li></ol><h3 id="运行-shell-脚本"><a href="#运行-shell-脚本" class="headerlink" title="运行 shell 脚本"></a>运行 shell 脚本</h3><ul><li><p>作为可执行程序</p><ol><li><p>使脚本具有执行权限</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x ./hello_world.sh<br></code></pre></td></tr></table></figure></li><li><p>执行脚本，注意要使用”.&#x2F;“表明是当前目录下的脚本，否则会去系统PATH中找</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./hello_world.sh  <br></code></pre></td></tr></table></figure></li></ol></li><li><p>作为解释器参数</p><p>直接运行解释器，将文件名作为参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/bin/sh hello_world.sh<br>/bin/php hello_world.php<br></code></pre></td></tr></table></figure></li></ul><h2 id="shell-变量"><a href="#shell-变量" class="headerlink" title="shell 变量"></a>shell 变量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ol><li><p>常规变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;fufu&quot;  # 字符串变量<br>LD_LIBRARY_PATH=&quot;/bin/&quot;  # 常量名一般用大写<br>declare -i var=123  # 使用declare或typeset声明整数变量<br>myarray=(1 2 3 4 5)  # 定义整数索引数组<br>declare -A associative_array  # 定义关联数组，类似Python的字典<br>associative_array[&quot;name&quot;]=&quot;fufu&quot;<br>associative_array[&quot;age&quot;]=20<br></code></pre></td></tr></table></figure></li><li><p>特殊变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;$PATH&quot;  # 环境变量，包含了操作系统搜索可执行文件的路径<br>echo &quot;$0&quot;  # 表示脚本的名称<br>echo &quot;$1&quot;  # 表示脚本第一个参数<br>echo &quot;$#&quot;  # 表示脚本的参数数量<br>echo &quot;$?&quot;  # 表示上一个命令的退出状态<br></code></pre></td></tr></table></figure></li></ol><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>注意：变量赋值时，变量名与等号之间不能有空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">正确的赋值</span><br>variable_name=value<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有可能会导致错误</span><br>variable_name = value<br></code></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，需要在变量名前加“$”符号，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;fufu&quot;<br>echo $name<br></code></pre></td></tr></table></figure><p>推荐使用“{}”包括变量，帮助解释器识别变量的边界，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for skill in Ada Coffe Action Java; do<br>    echo &quot;I am good at $&#123;skill&#125;Script&quot;<br>done<br></code></pre></td></tr></table></figure><h3 id="只读与删除"><a href="#只读与删除" class="headerlink" title="只读与删除"></a>只读与删除</h3><ul><li><p>只读变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">readonly name<br></code></pre></td></tr></table></figure></li><li><p>删除变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unset name<br></code></pre></td></tr></table></figure><p>注意：unset无法删除只读变量</p></li></ul><h3 id="shell-字符串"><a href="#shell-字符串" class="headerlink" title="shell 字符串"></a>shell 字符串</h3><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。</p><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;fufu&quot;<br>str=&#x27;this is %&#123;name&#125;.\n&#x27;<br>echo $str<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">this is %&#123;name&#125;.<br></code></pre></td></tr></table></figure><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;fufu&quot;<br>str=&quot;Hello, I know you are \&quot;$name\&quot;! \n&quot;<br>echo $str<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello, I know you are &quot;fufu&quot;! <br></code></pre></td></tr></table></figure><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;fufu&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用双引号拼接</span><br>greeting=&quot;hello, &quot;$your_name&quot; !&quot;<br>greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;<br>echo $greeting  $greeting_1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用单引号拼接</span><br>greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;<br>greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;<br>echo $greeting_2  $greeting_3<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello, fufu ! hello, fufu !<br>hello, fufu ! hello, $&#123;your_name&#125; !<br></code></pre></td></tr></table></figure><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;abcd&quot;<br>echo $&#123;#string&#125;   # 输出 4<br></code></pre></td></tr></table></figure><p>变量为字符串时，**<code>$&#123;#string&#125;</code>** 等价于 <strong><code>$&#123;#string[0]&#125;</code></strong>:</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;abcd&quot;<br>echo $&#123;#string[0]&#125;   # 输出 4<br></code></pre></td></tr></table></figure><h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><p>以下实例从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;runoob is a great site&quot;<br>echo $&#123;string:1:4&#125; # 输出 unoo<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：第一个字符的索引值为 <strong>0</strong>。</p><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;runoob is a great site&quot;<br>echo `expr index &quot;$string&quot; io`  # 输出 4<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 以上脚本中 <strong>&#96;</strong> 是反引号，而不是单引号 **’**，不要看错了哦。</p><h3 id="shell-数组"><a href="#shell-数组" class="headerlink" title="shell 数组"></a>shell 数组</h3><p>只支持一维数组，数组不限大小</p><h4 id="定义与索引"><a href="#定义与索引" class="headerlink" title="定义与索引"></a>定义与索引</h4><ol><li><p>整数索引数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义</span><br>array_name=(value0 value1 value2 value3)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">单独定义各分量</span><br>array_name[0]=value0<br>array_name[1]=value1<br></code></pre></td></tr></table></figure></li><li><p>关联数组</p><p>关联数组使用 <strong>declare</strong> 命令来声明，语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">直接定义赋值</span><br>declare -A array_name site=([&quot;google&quot;]=&quot;www.google.com&quot; [&quot;runoob&quot;]=&quot;www.runoob.com&quot; [&quot;taobao&quot;]=&quot;www.taobao.com&quot;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者先定义再赋值</span><br>declare -A site<br>site[&quot;google&quot;]=&quot;www.google.com&quot;<br>site[&quot;runoob&quot;]=&quot;www.runoob.com&quot;<br>site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;<br></code></pre></td></tr></table></figure></li></ol><h4 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h4><p>读取数组元素值的一般格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">valuen=$&#123;array_name[n]&#125;  # n为索引<br></code></pre></td></tr></table></figure><p>使用 <strong>@</strong> 或 ***** 符号可以获取数组中的所有元素，两者在返回值上有所不同：<code>@</code> 将每个参数单独返回，<code>*</code> 将参数合并后返回，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">array_name=(&quot;1&quot; &quot;2&quot; &quot;3&quot;)<br>echo $&#123;array_name[@]&#125;  # 输出等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;<br>echo $&#123;array_name[*]&#125;  # 输出等价于 &quot;1 2 3&quot;<br></code></pre></td></tr></table></figure><p>在数组前加一个感叹号 <strong>!</strong> 可以获取数组的所有索引&#x2F;键，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">declare -A site<br>site[&quot;google&quot;]=&quot;www.google.com&quot;<br>site[&quot;runoob&quot;]=&quot;www.runoob.com&quot;<br>site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;<br><br>echo &quot;数组的键为: $&#123;!site[*]&#125;&quot;<br>echo &quot;数组的键为: $&#123;!site[@]&#125;&quot;  # 数组的键为: google runoob taobao<br></code></pre></td></tr></table></figure><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">取得数组元素个数</span><br>num=$&#123;#my_array[*]&#125;<br>num=$&#123;#my_array[@]&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span><br>length=$&#123;#my_array[n]&#125;<br></code></pre></td></tr></table></figure><h2 id="shell-注释"><a href="#shell-注释" class="headerlink" title="shell 注释"></a>shell 注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><h4 id="使用-Here-文档"><a href="#使用-Here-文档" class="headerlink" title="使用 Here 文档"></a>使用 Here 文档</h4><p>用 “:&lt;&lt; ” 后面跟上任意字符或数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;EOF<br>注释内容...<br>注释内容...<br>注释内容...<br>EOF<br></code></pre></td></tr></table></figure><p>其中EOF可替换为其他任意字符</p><h4 id="使用“-”空命令"><a href="#使用“-”空命令" class="headerlink" title="使用“:”空命令"></a>使用“:”空命令</h4><p>格式为：<code>: + 空格 + 单引号。</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">: &#x27;<br>这是注释的部分。<br>可以有多行内容。<br>&#x27;<br></code></pre></td></tr></table></figure><h2 id="shell-传递参数"><a href="#shell-传递参数" class="headerlink" title="shell 传递参数"></a>shell 传递参数</h2><h3 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h3><p>执行 Shell 脚本时，可以向脚本传递参数，具体写法是在运行命令后以空格为间隔输入参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash hello_world.sh 1 2 3<br></code></pre></td></tr></table></figure><p>上面表示在运行 hello_world.sh 脚本时，向其中传入三个参数“1”、“2”、“3”</p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><p>脚本内获取参数的格式为 <strong>$n</strong>，<strong>n</strong> 代表一个数字，<strong>1</strong> 为执行脚本的第一个参数，<strong>2</strong> 为执行脚本的第二个参数。</p><p>例如，若 hello_world.sh 的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;Shell 传递参数实例！&quot;;<br>echo &quot;执行的文件名：$0&quot;;<br>echo &quot;第一个参数为：$1&quot;;<br>echo &quot;第二个参数为：$2&quot;;<br>echo &quot;第三个参数为：$3&quot;;<br></code></pre></td></tr></table></figure><p>则运行情况为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bash hello_world.sh 1 2 3<br>Shell 传递参数实例！<br><br>执行的文件名：hello_world.sh<br>第一个参数为：1<br>第二个参数为：2<br>第三个参数为：3<br></code></pre></td></tr></table></figure><p>此外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th align="left">参数处理</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$#</td><td align="left">传递到脚本的参数个数</td></tr><tr><td align="left">$*</td><td align="left">以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td align="left">$$</td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$@</td><td align="left">与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td align="left">$-</td><td align="left">显示Shell使用的当前选项，与 linux 的 set 命令功能相同。</td></tr><tr><td align="left">$?</td><td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数学建模七日谈收获</title>
    <link href="/2024/08/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%83%E6%97%A5%E8%B0%88%E6%94%B6%E8%8E%B7/"/>
    <url>/2024/08/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%83%E6%97%A5%E8%B0%88%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>七日谈原文链接：<a href="http://www.madio.net/article-399.html">http://www.madio.net/article-399.html</a></p></blockquote><h2 id="一、参加全国大学生数学建模比赛前你需要积累哪些"><a href="#一、参加全国大学生数学建模比赛前你需要积累哪些" class="headerlink" title="一、参加全国大学生数学建模比赛前你需要积累哪些"></a>一、参加全国大学生数学建模比赛前你需要积累哪些</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><ul><li>高数 + 线代</li><li>概率论和数理统计</li></ul><h3 id="2-系统学习数学建模"><a href="#2-系统学习数学建模" class="headerlink" title="2. 系统学习数学建模"></a>2. 系统学习数学建模</h3><ul><li><p>阅读相关专业书籍，系统学习各类模型，培养数学模型思维</p><p>书籍推荐：</p><ol><li>《数学模型》姜启源谢金星叶俊  高等教育出版社：基础+方法+思想</li><li>《数学建模算法与程序》司守奎  国防工业出版社：指导操作的教程</li></ol></li></ul><h2 id="二、怎样阅读数学模型教材"><a href="#二、怎样阅读数学模型教材" class="headerlink" title="二、怎样阅读数学模型教材"></a>二、怎样阅读数学模型教材</h2><p>对于任何一本教材，一份资料里介绍的一种数学模型的建立，或者一种算法，你都要问自己三个问题：</p><h3 id="1-这个模型叫什么名字？"><a href="#1-这个模型叫什么名字？" class="headerlink" title="1. 这个模型叫什么名字？"></a>1. 这个模型叫什么名字？</h3><p>通过论文形式与评委进行沟通的重要手段，要知道这个模型的名字、相关产生背景、和它类似的模型、有什么区别等等，这种文字性的东西的记忆最终会体现在论文的字里行间，积累越多，论文就会写得越流畅。</p><h3 id="2-这个模型属于什么类型，能够解决具有哪类特征的问题？"><a href="#2-这个模型属于什么类型，能够解决具有哪类特征的问题？" class="headerlink" title="2. 这个模型属于什么类型，能够解决具有哪类特征的问题？"></a>2. 这个模型属于什么类型，能够解决具有哪类特征的问题？</h3><p>深入了解模型的建立思想、阅读了一定的例子之后，自己在脑海里可以形成一个印象，这个方法可以解决什么类型的问题？问题的特征是什么？有什么样的背景可以联想到这个方法？这样，等出现类似的问题时，你会更加容易地搜索到对应的方法。</p><h3 id="3-这个模型的具体操作步骤怎么实现？"><a href="#3-这个模型的具体操作步骤怎么实现？" class="headerlink" title="3. 这个模型的具体操作步骤怎么实现？"></a>3. 这个模型的具体操作步骤怎么实现？</h3><p>操作层面上，这个模型可以用什么软件实现？参数怎么调？有没有现成的代码供参考？每一步的操作涵义是否清楚？当你明白了一个模型或者是算法的思想之后，软件操作和程序代码应该是像文思泉涌般跃然纸上才对，而且这个过程里会遇到很多意想不到的，纸上谈兵时看不到的困难，因为具体的操作要受你的系统环境、软件版本、时间限制等各种方面的现实考验，没有什么捷径，只有平时多练，多做，自然在临场你能最快地找到解决的办法。</p><h2 id="三、怎样进行论文阅读"><a href="#三、怎样进行论文阅读" class="headerlink" title="三、怎样进行论文阅读"></a>三、怎样进行论文阅读</h2><p>从作者解决这个问题的方法出发，还原回去：<strong>他是怎么想到这么做的？换了我能够形成这样正确而可行的思路吗？</strong></p><p><strong>要类比的是数学结构</strong>，而不是论文表面上所说的东西，以所读的论文为线索，梳理同类问题的解决方法。</p><p>只有平时思考问题的思维达到这个层次了，不浮于表面，你的举一反三，联想能力才能够真正发挥作用，能够知道遇到一个新问题，怎么找到学过的知识予以分析，解决。</p><h2 id="四、数学模型分类浅谈"><a href="#四、数学模型分类浅谈" class="headerlink" title="四、数学模型分类浅谈"></a>四、数学模型分类浅谈</h2><h3 id="1-优化类问题"><a href="#1-优化类问题" class="headerlink" title="1. 优化类问题"></a>1. 优化类问题</h3><p>对某些行为进行决策，这些是我们可以控制的因素，这些因素一般来说会定量化地影响我们的某些目标值，比如投入决定产出，价格决定销量等等。需要知道如何确定我们的决策变量，进而使得我们的目标值达到最优就是我们利用数学模型来解决的问题。</p><h3 id="2-评价类问题"><a href="#2-评价类问题" class="headerlink" title="2. 评价类问题"></a>2. 评价类问题</h3><p>每个行业都有它的评价标准和准则，那么这些标准应该有其自身的形成机制，数学模型就是形成这一机制的方法。数学模型的评价方法的一个优势在于，它能够最大程度上客观地反映被评价对象的优劣程度以及符合评价指标的多少，能够体现公平的原则；</p><h3 id="3-预测类问题"><a href="#3-预测类问题" class="headerlink" title="3. 预测类问题"></a>3. 预测类问题</h3><p>未来的情况往往可以根据当前的一些量予以推测和判断，这些当前的量再加上失去发展的机制，就能够推算出未来可能的情况。虽然前人总结的经典模型，一般可以拿来直接套用，但自己通过推断事物发展的机制进行算法设计然后预测，有时候才能够更加真实地反映未来的可能趋势。</p><p>这是从解决问题的类型的角度来分类，数学模型有这么三种用途，而还可以从数学思想方法的角度来分类，也就是数学思想层面的分类，这些就比较多了，而且内容也是浩如烟海，要结合着对解决问题类型的分类慢慢学习，多多思考，使自己解决问题的能力得到真正的提高。</p><h2 id="五、怎样问数学模型问题"><a href="#五、怎样问数学模型问题" class="headerlink" title="五、怎样问数学模型问题"></a>五、怎样问数学模型问题</h2><h3 id="问题是怎么产生的？"><a href="#问题是怎么产生的？" class="headerlink" title="问题是怎么产生的？"></a>问题是怎么产生的？</h3><p>问题的产生来源于建模的过程，也就是：</p><blockquote><p>实际问题 → 数学模型 → 数学求解 → 问题回答</p></blockquote><p>在建立一个模型，解决一道题目时，会“卡壳”的地方，也就是问题所在，无非出自于这四个步骤中间：</p><ol><li>对一个实际问题没有思路，找不到一个模型可以解决；</li><li>知道用哪个数学模型，但是模型的建立过程遇到困难，设计不出相应的算法；</li><li>建立模型以后，发现求解有困难，找不到现成的算法或者自己不知道设计；</li><li>发现得到的结果回答问题比较奇怪，却不知问题出在哪里。</li></ol><h3 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h3><ol><li><p>问题思路：可以是询问某类问题怎么解答，也可以是具体的题目寻求思路，</p><p>这时，我们可以根据我们的经验，告诉提问者最合适的模型，提出一些思考方向，让大家能够提高解题效率，慢慢地培养大家自己分析问题的能力，真正在数模能力上有所提高；</p></li><li><p>具体模型的相关疑问：知道用哪个模型，却不知道怎么建立和求解，或者求解结果不好也不知怎么改进，在这个过程中遇到的问题大多是由于对模型的数学机理还没有完全明白，不知道如何将书上的模型和具体题目相对应来求解，</p><p>我们版主会根据我们的经验指出这些模型怎么用，有哪些关键点，这样大家真正去领会这个模型的涵义，问题也就迎刃而解；</p></li><li><p>细节问题：某个软件如何安装、操作，某个算法的参数怎么调整，程序报错等等，</p></li></ol><p>  这些操作层面的问题希望大家自己尝试过再提，安装这类技术性问题我们有经验的版主会及时予以解答，至于程序报错可能等多的需要同学们自己多多调试，因为我们的回答会帮你解决当前的问题，但是程序调试能力是自己时间积累的结果。  </p><p>第一类问题对应于建模的第一步：<strong>找模型</strong>；</p><p>第二类问题对应于后面几步：<strong>建模和解模</strong>；</p><p>第三类的问题可以说是千奇百怪了，因为具体操作过程中会涉及到各种困难等着大家去克服。</p><p>大家遇到问题和看完我们的回答以后，一定都要看看这个问题在整个建模的大框架下属于哪一步，从前后联系的角度看看这样解决是否合理，而不是就问题而解决问题。所谓之授人以鱼不如授人以渔，这样，当下次再遇到类似的问题，大家就可以获得自己解决的能力，这样的话，才是建模能力的真正提高。</p><h2 id="六、组队建议和比赛流程建议"><a href="#六、组队建议和比赛流程建议" class="headerlink" title="六、组队建议和比赛流程建议"></a>六、组队建议和比赛流程建议</h2><h3 id="团队分工"><a href="#团队分工" class="headerlink" title="团队分工"></a>团队分工</h3><p>三个人的分工可以分为这几个方面：</p><ul><li><strong>数学员</strong>：知道一个问题该怎样一步步经过化简而变为数学问题，而在数学上又有哪些相关的方法能够求解，要精通算法，能够一定程度上帮助程序员想算法，总之，数学员要做到的是能够把一个问题清晰地用数学关系定义，然后给出求解的方向；</li><li><strong>程序员</strong>：负责实现数学员的想法，一些程序细节程序员必须非常明白，需要出图，出数据的地方必须能够非常迅速地给出；</li><li><strong>写手</strong>：在建立好的模型基础之上，将所有的图表，文字以一定的结构形式予以表达。要时刻要从评委，也就是论文阅读者的角度考虑问题，在全文中形成一个完整地逻辑框架。同时要做好排版的工作，最终能够把数学员建立的模型和程序员算出的结果以最清晰的方式体现在论文中。</li></ul><p>在全文的写作中，数学员负责搭建模型的框架结构，程序员负责计算结果并与数学员讨论，进而形成模型部分的全部内容，而写手要做的。就是在此基础之上，将所有的图表，文字以一定的结构形式予以表达，</p><p>团队一定要有分工明确而且互有合作，三个人都有其各自的特长，这样在某方面的问题的处理上才会保持高效率。三个人至少都能够擅长一方面的工作，同时相互之间也有交叉，这样，不至于在任何一个环节卡壳而没有人能够解决。因为每一项工作的工作量都比较庞大，因此，在准备的过程中就应该按照这个分工去准备而不要想着通吃。这样才真正达到了团队协作的效果。</p><h3 id="比赛流程"><a href="#比赛流程" class="headerlink" title="比赛流程"></a>比赛流程</h3><ul><li>第一天：定题+资料查找+模型框架：这一部分是模型的基础，确定模型的整体构架。</li><li>第二天：全面求解与调整框架：把自己对模型框架的搭建用各种手段实现。</li><li>第三天：论文初稿+摘要+反复修改全文：把模型变成论文并反复修改。</li></ul><h2 id="七、临近比赛时的准备工作"><a href="#七、临近比赛时的准备工作" class="headerlink" title="七、临近比赛时的准备工作"></a>七、临近比赛时的准备工作</h2><p>学习数模到最后参加数模比赛是一个持久战，在这持续很长的时间里除了坚持，有恒心，有毅力之外，还有一点重要的，就是状态的调整，良好的状态是成功的保证。</p><h3 id="还剩10天"><a href="#还剩10天" class="headerlink" title="还剩10天"></a>还剩10天</h3><p>对照一下数模的能力要求和自己队伍三个人的配合情况，查漏补缺，在一些重要而自己有没有掌握的一些知识点上再花些功夫。优化，评价，预测三类模型，一定不能有知识空白的地方，或多或少应该都有了解才是。</p><h3 id="还剩5天"><a href="#还剩5天" class="headerlink" title="还剩5天"></a>还剩5天</h3><p>对自己已经学过的知识作一下总结，翻看一下之前的笔记、资料，包括一切你曾经学过的论文，书籍，ppt等等，以浏览的方式进行，不必深入，能把之前积累过的东西活化，进而更容易、熟练地在比赛中用到。这时遇到不懂或者模糊的也大胆地跳过去，因为你要坚信，你不会的肯定不会考，考了的话你也可以用其他的知识跳过它！完全以一种放松的心态去应对。</p><h3 id="还剩1天"><a href="#还剩1天" class="headerlink" title="还剩1天"></a>还剩1天</h3><p>这个时候是放松的大好时机！今天既不要看书，也不要调程序！而是队伍里面三个人一起找个公园，找间教室，一起聊聊天，扯扯蛋，找个商店逛逛买点这几天可能用到的咖啡、面包之类的，然后彻底的放松一下，或者做一些简单的体育运动项目也可以，只要别耗掉太多体能就行。比赛前一天晚上，找一个馆子，一起好好吃一顿，算是饯行一样，大家同心协力，抱着统一的目标，一起努力去克服困难，解决问题。无论结果如何，这种一起努力思考的过程是很值得享受和回味的，大家可以在比赛中好好体验。</p><p>总之要做到临阵不乱，静下心来，心平气和地参加比赛，把它看做是一次团队作战的实践，日后遇到的困难、挑战、科研任务或是工作的一次模拟，用心对待它，无论结果如何，用心做过的事情，肯定会有意想不到的收获在未来的某一天回馈给你！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数模论文插图制作</title>
    <link href="/2024/07/29/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E6%8F%92%E5%9B%BE%E5%88%B6%E4%BD%9C/"/>
    <url>/2024/07/29/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E6%8F%92%E5%9B%BE%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="主要工具"><a href="#主要工具" class="headerlink" title="主要工具"></a>主要工具</h2><ol><li>PowerPoint：用于美化整理，微调图像（可以把每次做题的图放在同一个ppt文件里）</li><li>Excel：用于处理绘图要用的数据，基础作图</li><li>Python、Matlab：结合代码来作出基础图，美化的话可以先导出为pdf，然后利用Adobe Acrobat导出为ppt获得线条</li></ol><h2 id="常见作图类型"><a href="#常见作图类型" class="headerlink" title="常见作图类型"></a>常见作图类型</h2><h3 id="权重图、热力图"><a href="#权重图、热力图" class="headerlink" title="权重图、热力图"></a>权重图、热力图</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>将处理好的权重数据，使用Excel的色阶工具着色</li><li>拷贝到PowerPoint中，注意粘贴选项选择保留原格式</li><li>使用PowerPoint调整表格的边框长宽等基础属性</li></ol><h4 id="成品样例"><a href="#成品样例" class="headerlink" title="成品样例"></a>成品样例</h4><p><img src="https://cdn.jsdelivr.net/gh/fufu0615/img_bed@main/img/%E4%BD%BF%E7%94%A8ppt%E5%92%8Cexcel%E7%BB%98%E5%9B%BE/IMG_20240729-212839312.png" alt="图 2">  </p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>将散点数据处理成x, y两列分别代表点的横纵坐标的格式</li><li>使用office自带的散点图标即可做出基础图像</li><li>利用ppt设置散点图坐标和框线的格式，例：主刻度线类型（交叉）、次刻度线类型（内部）</li><li>修改美化散点图点的格式和背景格式，使之更贴合题目</li></ol><h4 id="成品样例-1"><a href="#成品样例-1" class="headerlink" title="成品样例"></a>成品样例</h4><p><img src="https://cdn.jsdelivr.net/gh/fufu0615/img_bed@main/img/office%E7%BB%98%E5%9B%BE%E7%BE%8E%E5%8C%96/IMG_20240729-215353904.png" alt="图 0">  </p><h3 id="着色图表"><a href="#着色图表" class="headerlink" title="着色图表"></a>着色图表</h3><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><p>主要是对作的基础图进行美化，可以分为两类：</p><ul><li>折线图、线性拟合图（主要是对线条和颜色进行美化）<ol><li>点实：点的颜色设得深一点</li><li>线透明：显得颜色设得稍浅</li><li>色彩对比鲜明：不同线之间使用对比色（用于单一张图）或同色系不同色调（用于多张相似图表，可以每张图使用一种色系）</li></ol></li><li>面积图（主要是在一块面积内填充渐变色来美化）<ol><li>可以利用PowerPoint中的图表设计 -&gt; 更改图表类型 -&gt; 组合图，实现折线图与面积图的搭配</li><li>注意office对于面积图的边缘没有平滑拟合，可能和做出来的折线图有区别</li></ol></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>多看优秀论文的作图，学习别人的图表表现方式</li><li>注意色彩搭配，可以参考网上的配色方案</li><li>不要滥用渐变色、阴影、虚线、发光等效果</li></ul><h4 id="成品样例-2"><a href="#成品样例-2" class="headerlink" title="成品样例"></a>成品样例</h4><p><img src="https://cdn.jsdelivr.net/gh/fufu0615/img_bed/img/img/202407292328976.png" alt="图 1"></p><p>未完待续……</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/07/28/test/"/>
    <url>/2024/07/28/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/27/hello-world/"/>
    <url>/2024/07/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
